<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TimeTracker Pro</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2563eb">
    <link rel="icon" type="image/png" sizes="192x192" href="time-tracker-grid-icon-192.png">
    <link rel="icon" type="image/png" sizes="512x512" href="time-tracker-grid-icon-512.png">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 8px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
            min-height: calc(100vh - 16px);
            display: flex;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #2563eb, #1d4ed8);
            color: white;
            padding: 16px;
            text-align: center;
            flex-shrink: 0;
        }

        .header h1 {
            font-size: 1.8rem;
            margin-bottom: 8px;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
            align-items: center;
            margin-top: 12px;
        }

        .date-controls {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 6px;
            padding: 2px;
        }

        .date-nav-btn {
            background: rgba(255,255,255,0.8);
            border: none;
            color: #2563eb;
            width: 32px;
            height: 32px;
            border-radius: 4px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .date-nav-btn:hover {
            background: rgba(255,255,255,0.9);
        }

        .date-input {
            padding: 6px 10px;
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 6px;
            background: rgba(255,255,255,0.1);
            color: white;
            font-size: 14px;
            min-width: 140px;
        }

        .date-input::-webkit-calendar-picker-indicator {
            filter: invert(1);
        }

        .btn {
            padding: 6px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            text-decoration: none;
            display: inline-block;
            white-space: nowrap;
        }

        .btn-primary {
            background: rgba(255,255,255,0.2);
            color: white;
            border: 2px solid rgba(255,255,255,0.3);
        }

        .btn-primary:hover {
            background: rgba(255,255,255,0.3);
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .sync-status {
            background: rgba(255,255,255,0.1);
            padding: 8px 12px;
            border-radius: 6px;
            margin-top: 8px;
            font-size: 11px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .sync-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255,255,255,0.1);
        }

        .sync-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .sync-dot.connected {
            background: #10b981;
        }

        .sync-dot.disconnected {
            background: #ef4444;
        }

        .status-connected {
            color: #10b981 !important;
            font-weight: bold;
        }

        .status-disconnected {
            color: #ef4444 !important;
            font-weight: bold;
        }

        .sync-dot.syncing {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .nav-tabs {
            display: flex;
            background: #f8fafc;
            border-bottom: 1px solid #e5e7eb;
            flex-shrink: 0;
        }

        .nav-tab {
            flex: 1;
            padding: 12px 8px;
            text-align: center;
            cursor: pointer;
            border: none;
            background: none;
            font-size: 14px;
            font-weight: 500;
            color: #64748b;
            transition: all 0.2s;
        }

        .nav-tab.active {
            background: white;
            color: #2563eb;
            border-bottom: 2px solid #2563eb;
        }

        .nav-tab:hover:not(.active) {
            background: #f1f5f9;
            color: #475569;
        }

        .main-content {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
        }

        .view {
            display: none;
        }

        .view.active {
            display: block;
        }

        /* Daily View Styles */
        .daily-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .daily-nav-btn {
            padding: 8px 12px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .daily-nav-btn:hover {
            background: #1d4ed8;
        }

        .daily-date {
            font-weight: 600;
            color: #1e293b;
            font-size: 16px;
        }

        .activity-selector {
            background: #f8fafc;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 16px;
        }

        .activity-selector h3 {
            margin-bottom: 12px;
            color: #1e293b;
            font-size: 16px;
        }

        .activity-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }

        .activity-btn {
            width: 44px;
            height: 44px;
            border: 2px solid #e2e8f0;
            border-radius: 8px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.2s;
        }

        .activity-btn:hover {
            border-color: #2563eb;
            transform: translateY(-1px);
        }

        .activity-btn.selected {
            background: #2563eb;
            color: white;
            border-color: #2563eb;
        }

        .time-grid {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 16px;
        }

        .grid-header {
            display: grid;
            grid-template-columns: 60px repeat(4, 1fr);
            background: #1e293b;
            color: white;
            font-weight: 600;
            font-size: 12px;
        }

        .grid-header div {
            padding: 8px 4px;
            text-align: center;
            border-right: 1px solid #374151;
        }

        .grid-row {
            display: grid;
            grid-template-columns: 60px repeat(4, 1fr);
            border-bottom: 1px solid #e5e7eb;
        }

        .grid-row:nth-child(even) {
            background: #f9fafb;
        }

        .hour-label {
            padding: 6px 4px;
            background: #f1f5f9;
            border-right: 1px solid #e5e7eb;
            font-weight: 600;
            color: #475569;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
        }

        .time-cell {
            padding: 6px 4px;
            border-right: 1px solid #e5e7eb;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            min-height: 32px;
        }

        .time-cell:hover {
            background: #dbeafe;
        }

        .time-cell.filled {
            background: #bfdbfe;
            color: #1e40af;
        }

        /* Weekly View Styles */
        .week-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .week-nav-btn {
            padding: 8px 12px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .week-nav-btn:hover {
            background: #1d4ed8;
        }

        .week-range {
            font-weight: 600;
            color: #1e293b;
        }

        .weekly-grid {
            background: white;
            border-radius: 8px;
            overflow-x: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .weekly-header {
            display: grid;
            grid-template-columns: 50px repeat(7, 1fr);
            background: #1e293b;
            color: white;
            font-weight: 600;
            font-size: 11px;
            min-width: 700px;
        }

        .weekly-header div {
            padding: 8px 4px;
            text-align: center;
            border-right: 1px solid #374151;
        }

        .weekly-row {
            display: grid;
            grid-template-columns: 50px repeat(7, 1fr);
            border-bottom: 1px solid #e5e7eb;
            min-width: 700px;
        }

        .weekly-row:nth-child(even) {
            background: #f9fafb;
        }

        .weekly-hour {
            padding: 4px 2px;
            background: #f1f5f9;
            border-right: 1px solid #e5e7eb;
            font-weight: 600;
            color: #475569;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
        }

        .weekly-cell {
            padding: 2px;
            border-right: 1px solid #e5e7eb;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 1px;
            min-height: 24px;
        }

        .interval-quarter {
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            border-radius: 2px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .interval-quarter.has-data {
            background: #bfdbfe;
            color: #1e40af;
        }

        .interval-quarter:hover {
            background: #dbeafe;
        }

        /* Habits View Styles */
        .habits-container {
            max-width: 800px;
            margin: 0 auto;
        }

        .habits-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .habits-nav-btn {
            padding: 8px 12px;
            background: #2563eb;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
        }

        .habits-nav-btn:hover {
            background: #1d4ed8;
        }

        .habits-period {
            font-weight: 600;
            color: #1e293b;
            text-align: center;
        }

        .habits-grid {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }

        .habits-header {
            display: grid;
            grid-template-columns: 120px repeat(7, 1fr);
            background: #1e293b;
            color: white;
            font-weight: 600;
            font-size: 12px;
        }

        .habits-header div {
            padding: 10px 4px;
            text-align: center;
            border-right: 1px solid #374151;
        }

        .habits-row {
            display: grid;
            grid-template-columns: 120px repeat(7, 1fr);
            border-bottom: 1px solid #e5e7eb;
        }

        .habits-row:nth-child(even) {
            background: #f9fafb;
        }

        .habit-label {
            padding: 12px 8px;
            background: #f1f5f9;
            border-right: 1px solid #e5e7eb;
            font-weight: 600;
            color: #475569;
            display: flex;
            align-items: center;
            font-size: 13px;
        }

        .habit-cell {
            padding: 8px;
            border-right: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 44px;
        }

        .habit-cell:hover {
            background: #dbeafe;
        }

        .habit-checkbox {
            width: 20px;
            height: 20px;
            border: 2px solid #d1d5db;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .habit-checkbox.checked {
            background: #10b981;
            border-color: #10b981;
            color: white;
        }

        .habit-checkbox.half {
            background: #f59e0b;
            border-color: #f59e0b;
            color: white;
        }

        .summary {
            margin-top: 16px;
            padding: 16px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .summary h3 {
            margin-bottom: 12px;
            color: #1e293b;
            font-size: 16px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 12px;
        }

        .summary-item {
            background: white;
            padding: 12px;
            border-radius: 6px;
            border-left: 4px solid #2563eb;
        }

        .summary-item .symbol {
            font-size: 16px;
            font-weight: bold;
            margin-bottom: 4px;
        }

        .summary-item .count {
            font-size: 12px;
            color: #64748b;
        }

        .setup-panel {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .setup-content {
            background: white;
            padding: 24px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .setup-section {
            margin-bottom: 24px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e5e7eb;
        }

        .setup-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

        .alert {
            padding: 10px;
            border-radius: 6px;
            margin: 8px 0;
            font-size: 13px;
        }

        .alert-success {
            background: #dcfce7;
            color: #166534;
            border: 1px solid #bbf7d0;
        }

        .alert-error {
            background: #fef2f2;
            color: #991b1b;
            border: 1px solid #fecaca;
        }

        .alert-info {
            background: #dbeafe;
            color: #1e40af;
            border: 1px solid #bfdbfe;
        }

        .debug-info {
            background: #f3f4f6;
            padding: 8px;
            border-radius: 4px;
            font-family: monospace;
            font-size: 10px;
            margin: 8px 0;
            max-height: 150px;
            overflow-y: auto;
        }

        .sync-setup {
            background: #f8fafc;
            padding: 12px;
            border-radius: 8px;
            margin: 12px 0;
        }

        .sign-in-btn {
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.2s;
            margin: 8px 0;
        }

        .github-btn {
            background: #24292e;
        }

        .github-btn:hover {
            background: #1a1e22;
        }

        .onedrive-btn {
            background: #0078d4;
        }

        .onedrive-btn:hover {
            background: #106ebe;
        }

        .sign-in-btn:disabled {
            background: #6b7280;
            cursor: not-allowed;
        }

        .token-input {
            width: 100%;
            padding: 8px;
            border: 1px solid #d1d5db;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
            margin: 8px 0;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            body {
                padding: 4px;
            }

            .container {
                border-radius: 8px;
                min-height: calc(100vh - 8px);
            }

            .header {
                padding: 12px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .controls {
                gap: 6px;
            }

            .btn {
                padding: 6px 10px;
                font-size: 12px;
            }

            .main-content {
                padding: 12px;
            }

            .nav-tab {
                padding: 10px 6px;
                font-size: 12px;
            }
        }

        /* Data Management Styles */
        .data-container {
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }

        .data-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 10px;
        }

        .data-controls {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .data-stats {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8fafc;
            border-radius: 8px;
            flex-wrap: wrap;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-width: 120px;
        }

        .stat-label {
            font-size: 12px;
            color: #6b7280;
            margin-bottom: 4px;
        }

        .stat-value {
            font-size: 18px;
            font-weight: bold;
            color: #1f2937;
        }

        .data-filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .data-filters input,
        .data-filters select {
            padding: 8px 12px;
            border: 1px solid #d1d5db;
            border-radius: 6px;
            font-size: 14px;
        }

        .data-table-container {
            overflow-x: auto;
            border: 1px solid #d1d5db;
            border-radius: 8px;
            max-height: 600px;
            overflow-y: auto;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        .data-table th {
            background: #f8fafc;
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #e5e7eb;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .data-table td {
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            vertical-align: middle;
        }

        .data-table tr:hover {
            background: #f8fafc;
        }

        .data-table .symbol-cell {
            font-weight: bold;
            font-size: 16px;
            text-align: center;
            width: 60px;
        }

        .data-table .key-cell {
            font-family: monospace;
            font-size: 12px;
            color: #6b7280;
            max-width: 100px;
            word-break: break-all;
        }

        .data-table .actions-cell {
            width: 80px;
        }

        .btn-delete {
            background: #dc2626;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }

        .btn-delete:hover {
            background: #b91c1c;
        }

        .duplicate-row {
            background: #fef2f2 !important;
        }

        .duplicate-row:hover {
            background: #fee2e2 !important;
        }

        .conflict-row {
            background: #fff7ed !important;
        }

        .conflict-row:hover {
            background: #fed7aa !important;
        }

        .conflict-dialog {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .conflict-content {
            background: white;
            padding: 24px;
            border-radius: 12px;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .conflict-entries {
            margin: 16px 0;
            padding: 12px;
            background: #f8fafc;
            border-radius: 8px;
        }

        .conflict-entry {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 8px;
            margin: 4px 0;
            border-radius: 6px;
            background: white;
            border: 1px solid #e5e7eb;
        }

        .conflict-entry input[type="radio"] {
            margin: 0;
        }

        .conflict-symbol {
            font-weight: bold;
            font-size: 18px;
            width: 30px;
            text-align: center;
        }

        .conflict-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div class="header-left">
                <h1>‚è∞ TimeTracker Pro</h1>
            </div>
            <div class="controls">
                <div class="date-nav">
                    <button class="date-nav-btn" onclick="navigateDate(-1)">‚Äπ</button>
                    <input type="date" id="currentDate" onchange="setCurrentDate(this.value)">
                    <button class="date-nav-btn" onclick="navigateDate(1)">‚Ä∫</button>
                </div>
                <button class="btn btn-secondary" onclick="showSetup()">‚öôÔ∏è Setup</button>
                <button class="btn btn-primary" onclick="syncToGitHub()" style="background: #dc2626;">üì§ GitHub Sync</button>
                <button class="btn btn-primary" onclick="loadFromGitHub()" style="background: #dc2626;">üì• GitHub Load</button>
                <button class="btn btn-primary" onclick="syncToOneDrive()" style="background: #0078d4;">‚òÅÔ∏è OneDrive Sync</button>
                <button class="btn btn-primary" onclick="loadFromOneDrive()" style="background: #3b82f6;">üì• Load</button>
                <button class="btn btn-secondary" onclick="exportData()">üì§ Export</button>
                <button class="btn btn-secondary" onclick="importData()">üì• Import</button>
            </div>
        </div>

        <div class="status-bar">
            <span class="sync-dot" id="githubDot"></span>
            <span id="githubStatus">GitHub: Manual sync available</span>
            <span id="onedriveStatus">OneDrive: Not connected</span>
            <span id="localStatus">Local: 0 entries</span>
        </div>

        <div class="nav-tabs">
            <div class="nav-tab active" onclick="showTab('daily')">üìÖ Daily</div>
            <div class="nav-tab" onclick="showTab('weekly')">üìä Weekly</div>
            <div class="nav-tab" onclick="showTab('habits')">üìà Habits</div>
            <div class="nav-tab" onclick="showTab('data')">üóÇÔ∏è Data</div>
        </div>

        <div class="main-content">
            <!-- Daily View -->
            <div id="dailyView" class="view active">
                <div class="daily-header">
                    <button class="daily-nav-btn" onclick="navigateDate(-1)">
                        ‚Üê Previous Day
                    </button>
                    <div class="daily-date" id="dailyDate"></div>
                    <button class="daily-nav-btn" onclick="navigateDate(1)">
                        Next Day ‚Üí
                    </button>
                </div>

                <div class="activity-selector">
                    <h3>Select Activity Symbol</h3>
                    <div class="activity-buttons">
                        <button class="activity-btn" data-symbol="‚óè" title="Wake up">‚óè</button>
                        <button class="activity-btn" data-symbol="‚úì" title="Work">‚úì</button>
                        <button class="activity-btn" data-symbol="P" title="Pomodoro">P</button>
                        <button class="activity-btn" data-symbol="M" title="Meditation">M</button>
                        <button class="activity-btn" data-symbol="J" title="Jogging">J</button>
                        <button class="activity-btn" data-symbol="‚óã" title="Social">‚óã</button>
                        <button class="activity-btn" data-symbol="√ó" title="Clear">√ó</button>
                    </div>
                </div>

                <div class="time-grid">
                    <div class="grid-header">
                        <div>Hour</div>
                        <div>:00-:15</div>
                        <div>:15-:30</div>
                        <div>:30-:45</div>
                        <div>:45-:00</div>
                    </div>
                    <div id="timeGrid"></div>
                </div>

                <div class="summary" id="summary"></div>
            </div>

            <!-- Weekly View -->
            <div id="weeklyView" class="view">
                <div class="week-navigation">
                    <button class="week-nav-btn" onclick="navigateWeek(-1)">‚Üê Previous</button>
                    <div class="week-range" id="weekRange"></div>
                    <button class="week-nav-btn" onclick="navigateWeek(1)">Next ‚Üí</button>
                </div>

                <div class="weekly-grid">
                    <div class="weekly-header" id="weeklyHeader"></div>
                    <div id="weeklyGrid"></div>
                </div>
            </div>

            <!-- Habits View -->
            <div id="habitsView" class="view">
                <div class="habits-container">
                    <div class="habits-navigation">
                        <button class="habits-nav-btn" onclick="navigateHabits(-1)">‚Üê Previous</button>
                        <div class="habits-period" id="habitsPeriod"></div>
                        <button class="habits-nav-btn" onclick="navigateHabits(1)">Next ‚Üí</button>
                    </div>

                    <div style="text-align: center; margin-bottom: 16px;">
                        <button class="btn btn-success" onclick="syncAllHabitsFromTimeLog(); updateHabitsView(); showAlert('Habits synced from time log!', 'success');">
                            üîÑ Sync Habits from Time Log
                        </button>
                    </div>

                    <div class="habits-grid" id="habitsGrid1"></div>
                    <div class="habits-grid" id="habitsGrid2"></div>
                </div>
            </div>

            <!-- Data Management View -->
            <div id="dataView" class="view">
                <div class="data-container">
                    <div class="data-header">
                        <h2>Data Management</h2>
                        <div class="data-controls">
                            <button class="btn btn-primary" onclick="refreshDataView()">üîÑ Refresh</button>
                            <button class="btn btn-warning" onclick="findDuplicates()">üîç Find Duplicates</button>
                            <button class="btn btn-danger" onclick="cleanAllDuplicates()">üßπ Clean Duplicates</button>
                        </div>
                    </div>
                    
                    <div class="data-stats">
                        <div class="stat-item">
                            <span class="stat-label">Total Entries:</span>
                            <span id="totalEntries" class="stat-value">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Dates with Data:</span>
                            <span id="totalDates" class="stat-value">0</span>
                        </div>
                        <div class="stat-item">
                            <span class="stat-label">Duplicates Found:</span>
                            <span id="duplicatesCount" class="stat-value">0</span>
                        </div>
                    </div>

                    <div class="data-filters">
                        <input type="text" id="dateFilter" placeholder="Filter by date (YYYY-MM-DD)" onkeyup="filterDataTable()">
                        <select id="symbolFilter" onchange="filterDataTable()">
                            <option value="">All Symbols</option>
                            <option value="‚óè">‚óè Wake up</option>
                            <option value="‚úì">‚úì Work</option>
                            <option value="P">P Pomodoro</option>
                            <option value="M">M Meditation</option>
                            <option value="J">J Jogging</option>
                            <option value="‚óã">‚óã Social</option>
                            <option value="√ó">√ó Clear</option>
                        </select>
                        <button class="btn btn-secondary" onclick="clearFilters()">Clear Filters</button>
                    </div>

                    <div class="data-table-container">
                        <table id="dataTable" class="data-table">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Time</th>
                                    <th>Symbol</th>
                                    <th>Key</th>
                                    <th>Actions</th>
                                </tr>
                            </thead>
                            <tbody id="dataTableBody">
                                <!-- Data rows will be populated here -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Setup Panel -->
    <div id="setupPanel" class="setup-panel" onclick="hideSetupOnOutsideClick(event)">
        <div class="setup-content" onclick="event.stopPropagation()">
            <h2>Sync Configuration</h2>
            
            <div id="debugInfo" class="debug-info">
                <strong>Status:</strong><br>
                <span id="debugLog">Initializing...</span>
            </div>
            
            <!-- GitHub Setup Section -->
            <div class="setup-section">
                <div class="sync-setup">
                    <h3>üêô GitHub Integration</h3>
                    <p>Connect your GitHub account to automatically sync your time tracking data to your repositories.</p>
                    
                    <div style="margin: 16px 0;">
                        <div id="githubAuthStatus" style="margin-bottom: 12px;">Status: Not connected</div>
                        
                        <div class="alert alert-info">
                            <strong>Setup Instructions:</strong><br>
                            1. Go to <a href="https://github.com/settings/tokens" target="_blank">GitHub Settings ‚Üí Personal Access Tokens</a><br>
                            2. Click "Generate new token (classic)"<br>
                            3. Select "repo" scope for repository access<br>
                            4. Copy the token and paste it below
                        </div>
                        
                        <input type="password" id="githubTokenInput" class="token-input" placeholder="Paste your GitHub Personal Access Token here..." />
                        
                        <div style="margin-top: 8px;">
                            <button class="btn btn-success" onclick="connectGitHub()" id="connectGithubBtn">
                                üîó Connect GitHub
                            </button>
                        </div>
                        
                        <div style="display: flex; gap: 8px; margin-top: 12px;">
                            <button class="btn btn-primary" onclick="testGitHubConnection()" id="testGithubBtn" style="display: none; background: #10b981;">
                                ‚úì Test Connection
                            </button>
                            <button class="btn btn-primary" onclick="syncToGitHub()" id="syncGithubBtn" style="display: none; background: #dc2626;">
                                üì§ GitHub Sync
                            </button>
                            <button class="btn btn-primary" onclick="loadFromGitHub()" id="loadGithubBtn" style="display: none; background: #3b82f6;">
                                üì• GitHub Load
                            </button>
                            <button class="btn btn-primary" onclick="disconnectGitHub()" id="disconnectGithubBtn" style="display: none; background: #6b7280;">
                                üö™ Sign Out
                            </button>
                        </div>
                    
                    <div id="githubResult"></div>
                </div>
            </div>

            <!-- OneDrive Setup Section -->
            <div class="setup-section">
                <div class="sync-setup">
                    <h3>üìÅ OneDrive Integration</h3>
                    <p>Connect your Microsoft account to sync time logs across devices.</p>
                    
                    <div style="margin: 16px 0;">
                        <div id="onedriveAuthStatus" style="margin-bottom: 12px;">Status: Loading...</div>
                        
                        <button class="sign-in-btn onedrive-btn" id="signInBtn" onclick="signInToOneDrive()" disabled>
                            <span>üîÑ</span>
                            <span>Loading Microsoft Sign-In...</span>
                        </button>
                        
                        <div id="signedInControls" style="display: none; margin-top: 12px;">
                            <button class="btn btn-success" onclick="testOneDriveConnection()" id="testOnedriveBtn">
                                üîó Test Connection
                            </button>
                            <button class="btn btn-danger" onclick="signOutFromOneDrive()" id="signOutBtn">
                                üö™ Sign Out
                            </button>
                        </div>
                    </div>
                    
                    <div id="onedriveResult"></div>
                </div>
            </div>

            <div style="margin-top: 16px; text-align: center; border-top: 1px solid #e5e7eb; padding-top: 16px;">
                <button class="btn btn-primary" onclick="restoreFromBackup()" style="margin-right: 8px; background: #f59e0b;">
                    üîÑ Restore Pre-Cleaning Backup
                </button>
                <button class="btn btn-primary" onclick="hideSetup()" style="padding: 10px 20px; font-size: 14px;">‚úï Close Setup</button>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let selectedSymbol = '‚óè';
        let currentDate = formatDate(new Date());
        let currentWeekStart = new Date();
        let currentHabitsWeek = new Date();
        let timeData = {};
        let habitsData = {};
        let msalInstance = null;
        let currentAccount = null;
        let githubToken = null;
        let githubUser = null;
        let debugLog = [];
        let msalLoadAttempts = 0;
        let currentView = 'daily';

        // Habits configuration
        const habitsConfig = [
            { id: 'reading', name: 'Reading', autoDetect: false },
            { id: 'oatmeal', name: 'Oatmeal', autoDetect: false },
            { id: 'jogging', name: 'Jogging', autoDetect: 'J' },
            { id: 'writing', name: 'Writing', autoDetect: false },
            { id: 'meditation', name: 'Meditation', autoDetect: 'M' },
            { id: 'stretching', name: 'Stretching', autoDetect: false },
            { id: 'nodrink', name: 'No Drink', autoDetect: false }
        ];

        // Debug logging function
        function addDebugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            debugLog.push(`${timestamp}: ${message}`);
            if (debugLog.length > 15) {
                debugLog.shift();
            }
            const debugElement = document.getElementById('debugLog');
            if (debugElement) {
                debugElement.innerHTML = debugLog.join('<br>');
            }
        }

        // Timezone-safe date handling functions
        function formatDate(date) {
            // Use local date components to avoid timezone issues
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function parseDate(dateString) {
            // Parse date string in local timezone
            const [year, month, day] = dateString.split('-').map(Number);
            return new Date(year, month - 1, day);
        }

        function addDays(date, days) {
            // Add days without timezone issues
            const result = new Date(date.getFullYear(), date.getMonth(), date.getDate());
            result.setDate(result.getDate() + days);
            return result;
        }

        function getWeekStart(date) {
            // Get Monday of the week containing the given date
            const dayOfWeek = date.getDay(); // 0=Sunday, 1=Monday, ..., 6=Saturday
            const mondayOffset = dayOfWeek === 0 ? -6 : 1 - dayOfWeek;
            return addDays(date, mondayOffset);
        }

        function formatDateDisplay(date) {
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        function formatDateLong(date) {
            return date.toLocaleDateString('en-US', { 
                weekday: 'long', 
                year: 'numeric', 
                month: 'long', 
                day: 'numeric' 
            });
        }

        // Date navigation functions
        function navigateDate(direction) {
            const currentDateObj = parseDate(currentDate);
            const newDate = addDays(currentDateObj, direction);
            currentDate = formatDate(newDate);
            
            document.getElementById('currentDate').value = currentDate;
            updateDailyDate();
            loadTimeData();
            generateTimeGrid();
            updateSummary();
            updateDataStatus();
            
            // Update other views if they're active
            if (currentView === 'weekly') {
                updateWeeklyView();
            }
            if (currentView === 'habits') {
                updateHabitsView();
            }
        }

        function updateDailyDate() {
            const dateObj = parseDate(currentDate);
            document.getElementById('currentDate').textContent = formatDateLong(dateObj);
        }

        // Sync status functions
        function updateSyncStatus() {
            updateGitHubStatus();
            updateOneDriveStatus();
            updateDataStatus();
        }

        function updateGitHubStatus() {
            const githubDot = document.getElementById('githubStatus');
            const githubStatus = document.getElementById('githubStatus');
            
            if (githubUser) {
                githubDot.className = 'sync-dot connected';
                githubStatus.textContent = `GitHub: ${githubUser.login}`;
            } else {
                githubDot.className = 'sync-dot disconnected';
                githubStatus.textContent = 'GitHub: Not connected';
            }
        }

        function updateOneDriveStatus() {
            const onedriveDot = document.getElementById('onedriveStatus');
            const onedriveStatus = document.getElementById('onedriveStatus');
            
            if (currentAccount) {
                onedriveDot.className = 'sync-dot connected';
                onedriveStatus.textContent = `OneDrive: ${currentAccount.username}`;
            } else {
                onedriveDot.className = 'sync-dot disconnected';
                onedriveStatus.textContent = 'OneDrive: Not connected';
            }
        }

        function updateDataStatus() {
            const dataStatus = document.getElementById('localStatus');
            const totalEntries = Object.keys(timeData).reduce((total, date) => {
                return total + Object.keys(timeData[date] || {}).length;
            }, 0);
            
            if (totalEntries > 0) {
                dataStatus.textContent = `Local: ${totalEntries} entries`;
            } else {
                dataStatus.textContent = 'Local: No data';
            }
        }

        function setSyncStatus(platform, status) {
            const dot = document.getElementById(platform + 'Dot');
            if (dot) {
                dot.className = `sync-dot ${status}`;
            }
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            addDebugLog('DOM loaded, initializing app...');
            
            // INITIALIZATION DEBUG
            const today = new Date();
            console.log('=== INITIALIZATION DEBUG ===');
            console.log('Today:', formatDate(today), '(' + today.toLocaleDateString('en-US', { weekday: 'long' }) + ')');
            
            // Set current week start to Monday using timezone-safe function
            currentWeekStart = getWeekStart(today);
            console.log('Week start (Monday):', formatDate(currentWeekStart));
            
            // Log all 7 days of the week for verification
            for (let i = 0; i < 7; i++) {
                const weekDay = addDays(currentWeekStart, i);
                const dayName = weekDay.toLocaleDateString('en-US', { weekday: 'short' });
                console.log(`Day ${i}: ${dayName} ${formatDate(weekDay)}`);
            }
            
            // Set habits week to current week
            currentHabitsWeek = new Date(currentWeekStart);
            
            document.getElementById('currentDate').value = currentDate;
            updateDailyDate();
            loadTimeData();
            loadHabitsData();
            
            // Load saved GitHub token
            loadGitHubAuth();
            
            // Sync habits from existing time log data on app load
            syncAllHabitsFromTimeLog();
            
            generateTimeGrid();
            updateSummary();
            setupEventListeners();
            updateWeeklyView();
            updateHabitsView();
            updateSyncStatus();
            
            // Start loading MSAL library
            setTimeout(() => {
                loadMSALLibrary();
            }, 500);
        });

        function setupEventListeners() {
            // Date change
            document.getElementById('currentDate').addEventListener('change', function() {
                currentDate = this.value;
                updateDailyDate();
                loadTimeData();
                generateTimeGrid();
                updateSummary();
                updateDataStatus();
                if (currentView === 'weekly') {
                    updateWeeklyView();
                }
                if (currentView === 'habits') {
                    updateHabitsView();
                }
            });

            // Activity button selection
            document.querySelectorAll('.activity-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    document.querySelectorAll('.activity-btn').forEach(b => b.classList.remove('selected'));
                    this.classList.add('selected');
                    selectedSymbol = this.dataset.symbol;
                });
            });

            // Select first activity by default
            document.querySelector('.activity-btn').classList.add('selected');
        }

        // View switching
        function switchView(viewName) {
            // Update nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => tab.classList.remove('active'));
            event.target.classList.add('active');
            
            // Update views
            document.querySelectorAll('.view').forEach(view => view.classList.remove('active'));
            document.getElementById(viewName + 'View').classList.add('active');
            
            currentView = viewName;
            
            // Update view-specific content
            if (viewName === 'weekly') {
                updateWeeklyView();
            } else if (viewName === 'habits') {
                // Auto-sync habits from time log when switching to habits view
                syncAllHabitsFromTimeLog();
                updateHabitsView();
            }
        }

        // Generate time grid for daily view
        function generateTimeGrid() {
            const grid = document.getElementById('timeGrid');
            grid.innerHTML = '';

            for (let hour = 5; hour < 29; hour++) {
                const displayHour = hour >= 24 ? hour - 24 : hour;
                const hourStr = String(displayHour).padStart(2, '0');
                
                const row = document.createElement('div');
                row.className = 'grid-row';
                
                const hourLabel = document.createElement('div');
                hourLabel.className = 'hour-label';
                hourLabel.textContent = hourStr + ':00';
                row.appendChild(hourLabel);
                
                for (let interval = 0; interval < 4; interval++) {
                    const cell = document.createElement('div');
                    cell.className = 'time-cell';
                    cell.dataset.hour = hour;
                    cell.dataset.interval = interval;
                    
                    const key = `${hour}-${interval}`;
                    const data = timeData[currentDate] || {};
                    if (data[key]) {
                        cell.textContent = data[key];
                        cell.classList.add('filled');
                    }
                    
                    cell.addEventListener('click', function() {
                        const hour = parseInt(this.dataset.hour);
                        const interval = parseInt(this.dataset.interval);
                        const key = `${hour}-${interval}`;
                        
                        if (!timeData[currentDate]) {
                            timeData[currentDate] = {};
                        }
                        
                        if (selectedSymbol === '√ó') {
                            delete timeData[currentDate][key];
                            this.textContent = '';
                            this.classList.remove('filled');
                        } else {
                            timeData[currentDate][key] = selectedSymbol;
                            this.textContent = selectedSymbol;
                            this.classList.add('filled');
                            
                            // Auto-detect habits
                            autoDetectHabits(currentDate, selectedSymbol);
                        }
                        
                        saveTimeData();
                        updateSummary();
                        updateDataStatus();
                        
                        // Update other views if they're active
                        if (currentView === 'weekly') {
                            updateWeeklyView();
                        }
                        if (currentView === 'habits') {
                            updateHabitsView();
                        }
                    });
                    
                    row.appendChild(cell);
                }
                
                grid.appendChild(row);
            }
        }

        // Generate weekly grid for weekly view
        function generateWeeklyGrid() {
            updateWeeklyView();
        }

        // Generate habits grid for habits view  
        function generateHabitsGrid() {
            updateHabitsView();
        }

        // Weekly view functions
        function updateWeeklyView() {
            console.log('=== WEEKLY VIEW DEBUG ===');
            console.log('Current week start:', formatDate(currentWeekStart));
            
            updateWeeklyHeader();
            updateWeeklyGrid();
        }

        function updateWeeklyHeader() {
            const header = document.getElementById('weeklyHeader');
            header.innerHTML = '';
            
            // Hour column
            const hourCol = document.createElement('div');
            hourCol.textContent = 'Hour';
            header.appendChild(hourCol);
            
            // Day columns (Monday to Sunday)
            for (let i = 0; i < 7; i++) {
                const date = addDays(currentWeekStart, i);
                const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
                const dayNum = date.getDate();
                
                const dayCol = document.createElement('div');
                dayCol.textContent = `${dayName} ${dayNum}`;
                header.appendChild(dayCol);
                
                console.log(`Column ${i}: ${dayName} ${dayNum} (${formatDate(date)})`);
            }
            
            // Update week range display
            const weekStart = formatDateDisplay(currentWeekStart);
            const weekEnd = formatDateDisplay(addDays(currentWeekStart, 6));
            document.getElementById('weekRange').textContent = `${weekStart} - ${weekEnd}`;
        }

        function updateWeeklyGrid() {
            const grid = document.getElementById('weeklyGrid');
            grid.innerHTML = '';
            
            for (let hour = 5; hour < 29; hour++) {
                const displayHour = hour >= 24 ? hour - 24 : hour;
                const hourStr = String(displayHour).padStart(2, '0');
                
                const row = document.createElement('div');
                row.className = 'weekly-row';
                
                // Hour label
                const hourLabel = document.createElement('div');
                hourLabel.className = 'weekly-hour';
                hourLabel.textContent = hourStr;
                row.appendChild(hourLabel);
                
                // Day cells (Monday to Sunday)
                for (let dayIndex = 0; dayIndex < 7; dayIndex++) {
                    const date = addDays(currentWeekStart, dayIndex);
                    const dateStr = formatDate(date);
                    
                    const dayCell = document.createElement('div');
                    dayCell.className = 'weekly-cell';
                    
                    // Create 4 quarters for 15-minute intervals
                    for (let interval = 0; interval < 4; interval++) {
                        const quarter = document.createElement('div');
                        quarter.className = 'interval-quarter';
                        
                        const key = `${hour}-${interval}`;
                        const data = timeData[dateStr] || {};
                        
                        if (data[key]) {
                            quarter.textContent = data[key];
                            quarter.classList.add('has-data');
                            
                            // Add tooltip
                            const startMin = interval * 15;
                            const endMin = (interval + 1) * 15;
                            const startTime = `${hourStr}:${String(startMin).padStart(2, '0')}`;
                            const endTime = endMin === 60 ? `${String(displayHour + 1).padStart(2, '0')}:00` : `${hourStr}:${String(endMin).padStart(2, '0')}`;
                            quarter.title = `${startTime}-${endTime} - ${data[key]}`;
                            
                            console.log(`Found data for ${dateStr} hour ${hour} interval ${interval}: ${data[key]}`);
                        }
                        
                        dayCell.appendChild(quarter);
                    }
                    
                    row.appendChild(dayCell);
                }
                
                grid.appendChild(row);
            }
        }

        function navigateWeek(direction) {
            currentWeekStart = addDays(currentWeekStart, direction * 7);
            updateWeeklyView();
        }

        // Habits view functions
        function updateHabitsView() {
            console.log('=== HABITS VIEW DEBUG ===');
            console.log('Current habits week start:', formatDate(currentHabitsWeek));
            
            updateHabitsGrid('habitsGrid1', currentHabitsWeek);
            updateHabitsGrid('habitsGrid2', addDays(currentHabitsWeek, 7));
            
            const weekStart1 = formatDateDisplay(currentHabitsWeek);
            const weekEnd1 = formatDateDisplay(addDays(currentHabitsWeek, 6));
            const weekStart2 = formatDateDisplay(addDays(currentHabitsWeek, 7));
            const weekEnd2 = formatDateDisplay(addDays(currentHabitsWeek, 13));
            
            document.getElementById('habitsPeriod').innerHTML = 
                `${weekStart1} - ${weekEnd1}<br>${weekStart2} - ${weekEnd2}`;
        }

        function updateHabitsGrid(gridId, weekStart) {
            const grid = document.getElementById(gridId);
            grid.innerHTML = '';
            
            // Header
            const header = document.createElement('div');
            header.className = 'habits-header';
            
            const habitCol = document.createElement('div');
            habitCol.textContent = 'Habit';
            header.appendChild(habitCol);
            
            for (let i = 0; i < 7; i++) {
                const date = addDays(weekStart, i);
                const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
                const dayNum = date.getDate();
                
                const dayCol = document.createElement('div');
                dayCol.textContent = `${dayName} ${dayNum}`;
                header.appendChild(dayCol);
                
                console.log(`Habits column ${i}: ${dayName} ${dayNum} (${formatDate(date)})`);
            }
            
            grid.appendChild(header);
            
            // Habit rows
            habitsConfig.forEach(habit => {
                const row = document.createElement('div');
                row.className = 'habits-row';
                
                const label = document.createElement('div');
                label.className = 'habit-label';
                label.textContent = habit.name;
                row.appendChild(label);
                
                for (let i = 0; i < 7; i++) {
                    const date = addDays(weekStart, i);
                    const dateStr = formatDate(date);
                    
                    const cell = document.createElement('div');
                    cell.className = 'habit-cell';
                    
                    const checkbox = document.createElement('div');
                    checkbox.className = 'habit-checkbox';
                    
                    const habitKey = `${dateStr}-${habit.id}`;
                    const habitValue = habitsData[habitKey] || 0;
                    
                    if (habitValue === 1) {
                        checkbox.classList.add('checked');
                        checkbox.textContent = '‚úì';
                    } else if (habitValue === 0.5) {
                        checkbox.classList.add('half');
                        checkbox.textContent = '¬Ω';
                    }
                    
                    checkbox.addEventListener('click', function() {
                        const currentValue = habitsData[habitKey] || 0;
                        let newValue;
                        
                        if (currentValue === 0) {
                            newValue = 1; // Empty -> Full
                        } else if (currentValue === 1) {
                            newValue = 0.5; // Full -> Half
                        } else {
                            newValue = 0; // Half -> Empty
                        }
                        
                        if (newValue === 0) {
                            delete habitsData[habitKey];
                        } else {
                            habitsData[habitKey] = newValue;
                        }
                        
                        saveHabitsData();
                        updateHabitsView();
                    });
                    
                    cell.appendChild(checkbox);
                    row.appendChild(cell);
                }
                
                grid.appendChild(row);
            });
        }

        function navigateHabits(direction) {
            currentHabitsWeek = addDays(currentHabitsWeek, direction * 14);
            updateHabitsView();
        }

        function autoDetectHabits(date, symbol) {
            habitsConfig.forEach(habit => {
                if (habit.autoDetect === symbol) {
                    const habitKey = `${date}-${habit.id}`;
                    if (!habitsData[habitKey]) {
                        habitsData[habitKey] = 1;
                        saveHabitsData();
                        console.log(`Auto-detected ${habit.name} for ${date}`);
                    }
                }
            });
        }

        function syncAllHabitsFromTimeLog() {
            console.log('=== SYNCING HABITS FROM TIME LOG ===');
            console.log('Available time data dates:', Object.keys(timeData));
            
            Object.keys(timeData).forEach(date => {
                console.log(`Processing date: ${date}`);
                const dayData = timeData[date];
                
                Object.values(dayData).forEach(symbol => {
                    habitsConfig.forEach(habit => {
                        if (habit.autoDetect === symbol) {
                            const habitKey = `${date}-${habit.id}`;
                            if (!habitsData[habitKey]) {
                                habitsData[habitKey] = 1;
                                console.log(`Synced ${habit.name} habit for ${date} from symbol ${symbol}`);
                            }
                        }
                    });
                });
            });
            
            saveHabitsData();
            console.log('Habits sync completed');
        }

        // Summary functions - Fixed to handle Wake Up symbol properly and prevent duplicates
        function updateSummary() {
            const data = timeData[currentDate] || {};
            const summary = document.getElementById('summary');
            
            console.log('=== SUMMARY DEBUG ===');
            console.log('Raw data for', currentDate, ':', data);
            
            const symbolCounts = {};
            let wakeUpTime = null;
            
            // Count symbols and find wake up time
            Object.entries(data).forEach(([key, symbol]) => {
                // Ensure symbol is a string
                const symbolStr = String(symbol);
                console.log(`Processing ${key}: ${symbolStr}`);
                
                if (symbolStr === '‚óè') {
                    // Wake up symbol - find the earliest occurrence
                    const [hour, interval] = key.split('-').map(Number);
                    if (!isNaN(hour) && !isNaN(interval)) {
                        const timeInMinutes = hour * 60 + interval * 15;
                        if (wakeUpTime === null || timeInMinutes < wakeUpTime) {
                            wakeUpTime = timeInMinutes;
                        }
                        console.log(`Found wake up at ${hour}:${interval} (${timeInMinutes} minutes)`);
                    }
                } else if (symbolStr && symbolStr !== 'undefined' && symbolStr !== 'null' && symbolStr !== '‚óè') {
                    // Count other symbols as intervals (only valid symbols, excluding wake up)
                    symbolCounts[symbolStr] = (symbolCounts[symbolStr] || 0) + 1;
                    console.log(`Counted ${symbolStr}: now ${symbolCounts[symbolStr]}`);
                }
            });
            
            console.log('Final symbol counts:', symbolCounts);
            console.log('Wake up time (minutes):', wakeUpTime);
            
            const symbolNames = {
                '‚úì': 'Work',
                'P': 'Pomodoro',
                'M': 'Meditation',
                'J': 'Jogging',
                '‚óã': 'Social',
                '√ó': 'Clear'
            };
            
            let summaryHTML = '<h3>Daily Summary</h3><div class="summary-grid">';
            
            // Add wake up time if found
            if (wakeUpTime !== null && !isNaN(wakeUpTime)) {
                const wakeUpHour = Math.floor(wakeUpTime / 60);
                const wakeUpMin = wakeUpTime % 60;
                const displayHour = wakeUpHour >= 24 ? wakeUpHour - 24 : wakeUpHour;
                const timeStr = `${String(displayHour).padStart(2, '0')}:${String(wakeUpMin).padStart(2, '0')}`;
                
                summaryHTML += `
                    <div class="summary-item">
                        <div class="symbol">‚óè Wake up</div>
                        <div class="count">Started at ${timeStr}</div>
                    </div>
                `;
            }
            
            // Add other activities
            Object.entries(symbolCounts).forEach(([symbol, count]) => {
                // Ensure we have a valid symbol string
                if (symbol && symbol !== 'undefined' && symbol !== 'null' && symbol !== '‚óè') {
                    const name = symbolNames[symbol] || 'Other';
                    const hours = (count * 0.25).toFixed(2);
                    summaryHTML += `
                        <div class="summary-item">
                            <div class="symbol">${symbol} ${name}</div>
                            <div class="count">${count} intervals (${hours} hours)</div>
                        </div>
                    `;
                }
            });
            
            summaryHTML += '</div>';
            summary.innerHTML = summaryHTML;
        }

        // Data management
        function saveTimeData() {
            localStorage.setItem('timeTrackerData', JSON.stringify(timeData));
            updateDataStatus();
        }

        function loadTimeData() {
            const saved = localStorage.getItem('timeTrackerData');
            if (saved) {
                try {
                    timeData = JSON.parse(saved);
                    // Clean corrupted data
                    cleanTimeData();
                } catch (error) {
                    console.log('Error loading time data:', error);
                    timeData = {};
                }
            }
            updateDataStatus();
        }

        function cleanTimeData() {
            // First, check if cleaning is needed
            let needsCleaning = false;
            let duplicatesFound = 0;
            
            Object.keys(timeData).forEach(date => {
                const dayData = timeData[date];
                if (dayData && typeof dayData === 'object') {
                    // Check for duplicate time slots (same time with multiple entries)
                    const timeSlots = {};
                    
                    Object.keys(dayData).forEach(key => {
                        const value = dayData[key];
                        
                        // Track time slots to detect duplicates
                        if (timeSlots[key]) {
                            duplicatesFound++;
                            needsCleaning = true;
                            console.log(`Duplicate found for ${date} ${key}: existing=${timeSlots[key]}, new=${value}`);
                        } else {
                            timeSlots[key] = value;
                        }
                        
                        // Check if this entry needs cleaning
                        if (typeof value === 'object' && value !== null) {
                            needsCleaning = true;
                        } else if (typeof value === 'string' && value.length > 1 && !['‚óè', '‚úì', 'P', 'M', 'J', '‚óã', '√ó'].includes(value)) {
                            if (value.includes('object') || value.length > 5) {
                                needsCleaning = true;
                            }
                        }
                    });
                }
            });
            
            // If no cleaning needed, return early
            if (!needsCleaning) {
                console.log('No data cleaning needed');
                return;
            }
            
            console.log(`Found ${duplicatesFound} duplicate entries that need cleaning`);
            
            // Create automatic backup before cleaning
            console.log('Creating automatic backup before data cleaning...');
            createPreCleaningBackup();
            
            let cleaned = false;
            
            Object.keys(timeData).forEach(date => {
                const dayData = timeData[date];
                if (dayData && typeof dayData === 'object') {
                    const cleanedDayData = {};
                    
                    Object.keys(dayData).forEach(key => {
                        const value = dayData[key];
                        
                        // Only keep the first valid entry for each time slot (deduplication)
                        if (!cleanedDayData[key]) {
                            // Fix corrupted data - convert objects to strings or remove them
                            if (typeof value === 'object' && value !== null) {
                                console.log(`Cleaning corrupted data for ${date} ${key}:`, value);
                                
                                // Try to extract a meaningful symbol from the object
                                if (value.symbol && typeof value.symbol === 'string') {
                                    cleanedDayData[key] = value.symbol;
                                } else if (value.toString && value.toString() !== '[object Object]') {
                                    cleanedDayData[key] = value.toString();
                                } else {
                                // Remove corrupted entry
                                console.log(`Removing corrupted object for ${date} ${key}`);
                                cleaned = true;
                            }
                        } else if (typeof value === 'string' && value.length > 1 && !['‚óè', '‚úì', 'P', 'M', 'J', '‚óã', '√ó'].includes(value)) {
                            // If it's a long string that's not a valid symbol, remove it
                            if (value.includes('object') || value.length > 5) {
                                console.log(`Removing invalid symbol for ${date} ${key}:`, value);
                                cleaned = true;
                            } else {
                                // Keep valid single character symbols
                                cleanedDayData[key] = value;
                            }
                        } else if (typeof value === 'string' && ['‚óè', '‚úì', 'P', 'M', 'J', '‚óã', '√ó'].includes(value)) {
                            // Keep valid symbols
                            cleanedDayData[key] = value;
                        }
                        // Skip duplicates (already have an entry for this time slot)
                        } else {
                            console.log(`Skipping duplicate entry for ${date} ${key}: ${value}`);
                            cleaned = true;
                        }
                    });
                    
                    // Replace the day data with cleaned version
                    timeData[date] = cleanedDayData;
                }
            });
            
            if (cleaned) {
                console.log('Data cleaned, saving...');
                saveTimeData();
                showAlert('Data cleaned successfully! Backup created automatically.', 'success');
            }
        }

        function debugCurrentData() {
            console.log('=== CURRENT DATA DEBUG ===');
            console.log('Current date:', currentDate);
            console.log('Time data for current date:', timeData[currentDate]);
            
            if (timeData[currentDate]) {
                const entries = Object.entries(timeData[currentDate]);
                console.log('Number of entries:', entries.length);
                
                const symbolCounts = {};
                entries.forEach(([key, symbol]) => {
                    console.log(`${key}: ${symbol} (type: ${typeof symbol})`);
                    symbolCounts[symbol] = (symbolCounts[symbol] || 0) + 1;
                });
                
                console.log('Symbol counts:', symbolCounts);
            }
            
            return timeData[currentDate];
        }

        function createPreCleaningBackup() {
            try {
                const backupData = {
                    timeData: timeData,
                    habitsData: habitsData,
                    backupDate: new Date().toISOString(),
                    backupType: 'pre-cleaning-auto',
                    note: 'Automatic backup created before data cleaning'
                };
                
                const blob = new Blob([JSON.stringify(backupData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `timetracker-pre-cleaning-backup-${formatDate(new Date())}-${Date.now()}.json`;
                
                // Auto-download the backup
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                console.log('Pre-cleaning backup created and downloaded');
                
                // Also store backup in localStorage as fallback
                localStorage.setItem('timeTrackerPreCleaningBackup', JSON.stringify(backupData));
                
            } catch (error) {
                console.error('Failed to create pre-cleaning backup:', error);
                showAlert('Warning: Could not create backup before cleaning', 'error');
            }
        }

        function restoreFromBackup() {
            try {
                const backup = localStorage.getItem('timeTrackerPreCleaningBackup');
                if (backup) {
                    const backupData = JSON.parse(backup);
                    
                    if (confirm('Restore data from the automatic pre-cleaning backup? This will overwrite current data.')) {
                        if (backupData.timeData) {
                            timeData = backupData.timeData;
                            saveTimeData();
                        }
                        
                        if (backupData.habitsData) {
                            habitsData = backupData.habitsData;
                            saveHabitsData();
                        }
                        
                        generateTimeGrid();
                        updateSummary();
                        updateWeeklyView();
                        updateHabitsView();
                        updateDataStatus();
                        
                        showAlert('Data restored from pre-cleaning backup successfully!', 'success');
                    }
                } else {
                    showAlert('No pre-cleaning backup found', 'error');
                }
            } catch (error) {
                showAlert('Error restoring backup: ' + error.message, 'error');
            }
        }

        function saveHabitsData() {
            localStorage.setItem('timeTrackerHabits', JSON.stringify(habitsData));
        }

        function loadHabitsData() {
            const saved = localStorage.getItem('timeTrackerHabits');
            if (saved) {
                habitsData = JSON.parse(saved);
            }
        }

        function exportData() {
            const exportData = {
                timeData: timeData,
                habitsData: habitsData,
                exportDate: new Date().toISOString()
            };
            
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `timetracker-backup-${formatDate(new Date())}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            showAlert('Data exported successfully!', 'success');
        }

        function importData() {
            document.getElementById('importFile').click();
        }

        function handleImport(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    
                    if (importedData.timeData) {
                        timeData = { ...timeData, ...importedData.timeData };
                        saveTimeData();
                    }
                    
                    if (importedData.habitsData) {
                        habitsData = { ...habitsData, ...importedData.habitsData };
                        saveHabitsData();
                    }
                    
                    generateTimeGrid();
                    updateSummary();
                    updateWeeklyView();
                    updateHabitsView();
                    updateDataStatus();
                    
                    showAlert('Data imported successfully!', 'success');
                } catch (error) {
                    showAlert('Error importing data: ' + error.message, 'error');
                }
            };
            reader.readAsText(file);
        }

        // Setup panel functions
        function showSetup() {
            document.getElementById('setupPanel').style.display = 'flex';
        }

        function hideSetup() {
            document.getElementById('setupPanel').style.display = 'none';
        }

        function hideSetupOnOutsideClick(event) {
            if (event.target === event.currentTarget) {
                hideSetup();
            }
        }

        // Alert system
        function showAlert(message, type = 'info') {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            
            document.body.appendChild(alertDiv);
            
            setTimeout(() => {
                alertDiv.remove();
            }, 3000);
        }

        // GitHub integration functions
        function loadGitHubAuth() {
            const savedToken = localStorage.getItem('github_token');
            if (savedToken) {
                githubToken = savedToken;
                loadGitHubUser();
            }
        }

        async function connectGitHub() {
            const token = document.getElementById('githubTokenInput').value.trim();
            if (!token) {
                showAlert('Please enter a GitHub Personal Access Token', 'error');
                return;
            }

            try {
                addDebugLog('Testing GitHub token...');
                
                const response = await fetch('https://api.github.com/user', {
                    headers: {
                        'Authorization': `token ${token}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (response.ok) {
                    githubUser = await response.json();
                    githubToken = token;
                    localStorage.setItem('github_token', token);
                    
                    updateGitHubAuthStatus();
                    showGitHubConnectedControls();
                    updateGitHubStatus();
                    
                    showAlert(`GitHub connected successfully as ${githubUser.login}!`, 'success');
                    addDebugLog(`Connected to GitHub as ${githubUser.login}`);
                } else {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
            } catch (error) {
                addDebugLog('GitHub connection failed: ' + error.message);
                showAlert('GitHub connection failed: ' + error.message, 'error');
            }
        }

        async function loadGitHubUser() {
            if (!githubToken) return;

            try {
                const response = await fetch('https://api.github.com/user', {
                    headers: {
                        'Authorization': `token ${githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (response.ok) {
                    githubUser = await response.json();
                    updateGitHubAuthStatus();
                    showGitHubConnectedControls();
                    updateGitHubStatus();
                } else {
                    throw new Error('Token invalid');
                }
            } catch (error) {
                console.log('GitHub user load failed:', error.message);
                githubToken = null;
                githubUser = null;
                localStorage.removeItem('github_token');
                updateGitHubStatus();
            }
        }

        function updateGitHubAuthStatus() {
            const status = document.getElementById('githubAuthStatus');
            if (githubUser) {
                status.textContent = `Status: Connected as ${githubUser.login}`;
            } else {
                status.textContent = 'Status: Not connected';
            }
        }

        function showGitHubConnectedControls() {
            document.getElementById('connectGithubBtn').style.display = 'none';
            document.getElementById('testGithubBtn').style.display = 'inline-block';
            document.getElementById('syncGithubBtn').style.display = 'inline-block';
            document.getElementById('loadGithubBtn').style.display = 'inline-block';
            document.getElementById('disconnectGithubBtn').style.display = 'inline-block';
        }

        function hideGitHubConnectedControls() {
            document.getElementById('connectGithubBtn').style.display = 'inline-block';
            document.getElementById('testGithubBtn').style.display = 'none';
            document.getElementById('syncGithubBtn').style.display = 'none';
            document.getElementById('loadGithubBtn').style.display = 'none';
            document.getElementById('disconnectGithubBtn').style.display = 'none';
        }

        async function testGitHubConnection() {
            if (!githubToken) {
                showAlert('Please connect to GitHub first', 'error');
                return;
            }

            try {
                const response = await fetch('https://api.github.com/user/repos', {
                    headers: {
                        'Authorization': `token ${githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });

                if (response.ok) {
                    const repos = await response.json();
                    showAlert(`GitHub connection successful! Found ${repos.length} repositories.`, 'success');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                showAlert('GitHub connection failed: ' + error.message, 'error');
            }
        }

        async function syncToGitHub() {
            if (!githubToken || !githubUser) {
                showAlert('Please connect to GitHub first', 'error');
                showSetup();
                return;
            }

            try {
                setSyncStatus('github', 'syncing');
                addDebugLog('Starting GitHub full database sync...');
                
                // Create or get repository
                const repoName = 'timetracker-data';
                await createOrUpdateGitHubRepo(repoName);
                
                // Upload full database
                const fullData = {
                    timeData: timeData,
                    habitsData: habitsData,
                    lastSync: new Date().toISOString(),
                    deviceInfo: {
                        userAgent: navigator.userAgent,
                        platform: navigator.platform,
                        timestamp: Date.now()
                    }
                };
                
                const fullDataContent = JSON.stringify(fullData, null, 2);
                
                // Upload full database file to GitHub
                await uploadToGitHub(repoName, 'timetracker-full-data.json', fullDataContent, 'Update full database - ' + new Date().toISOString());
                
                setSyncStatus('github', 'connected');
                showAlert('Full database synced to GitHub successfully!', 'success');
                addDebugLog('GitHub full database sync completed successfully');
                
            } catch (error) {
                setSyncStatus('github', 'disconnected');
                showAlert('GitHub sync failed: ' + error.message, 'error');
                addDebugLog('GitHub sync failed: ' + error.message);
            }
        }

        async function createOrUpdateGitHubRepo(repoName) {
            try {
                // Check if repo exists
                const checkResponse = await fetch(`https://api.github.com/repos/${githubUser.login}/${repoName}`, {
                    headers: {
                        'Authorization': `token ${githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (checkResponse.status === 404) {
                    // Create new repository
                    addDebugLog('Creating new repository...');
                    const createResponse = await fetch('https://api.github.com/user/repos', {
                        method: 'POST',
                        headers: {
                            'Authorization': `token ${githubToken}`,
                            'Accept': 'application/vnd.github.v3+json',
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            name: repoName,
                            description: 'TimeTracker Pro - Personal time tracking data',
                            private: true,
                            auto_init: true
                        })
                    });
                    
                    if (!createResponse.ok) {
                        throw new Error(`Failed to create repository: ${createResponse.status}`);
                    }
                    addDebugLog('Repository created successfully');
                } else if (checkResponse.ok) {
                    addDebugLog('Repository already exists');
                } else {
                    throw new Error(`Failed to check repository: ${checkResponse.status}`);
                }
            } catch (error) {
                addDebugLog('Repository setup error: ' + error.message);
                throw error;
            }
        }

        async function uploadToGitHub(repoName, fileName, content, commitMessage) {
            try {
                addDebugLog(`Uploading ${fileName}...`);
                
                // Get current file SHA if it exists
                let sha = null;
                try {
                    const getResponse = await fetch(`https://api.github.com/repos/${githubUser.login}/${repoName}/contents/${fileName}`, {
                        headers: {
                            'Authorization': `token ${githubToken}`,
                            'Accept': 'application/vnd.github.v3+json'
                        }
                    });
                    
                    if (getResponse.ok) {
                        const fileData = await getResponse.json();
                        sha = fileData.sha;
                        addDebugLog(`Found existing ${fileName}, updating...`);
                    } else {
                        addDebugLog(`Creating new ${fileName}...`);
                    }
                } catch (e) {
                    // File doesn't exist, that's fine
                }
                
                // Upload or update file
                const uploadData = {
                    message: commitMessage,
                    content: btoa(unescape(encodeURIComponent(content))), // Base64 encode
                };
                
                if (sha) {
                    uploadData.sha = sha;
                }
                
                const uploadResponse = await fetch(`https://api.github.com/repos/${githubUser.login}/${repoName}/contents/${fileName}`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `token ${githubToken}`,
                        'Accept': 'application/vnd.github.v3+json',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(uploadData)
                });

                if (!uploadResponse.ok) {
                    const errorData = await uploadResponse.json();
                    throw new Error(`Upload failed: ${uploadResponse.status} - ${errorData.message}`);
                }
                
                addDebugLog(`${fileName} uploaded successfully`);
            } catch (error) {
                addDebugLog(`Failed to upload ${fileName}: ${error.message}`);
                throw new Error(`Failed to upload ${fileName}: ${error.message}`);
            }
        }

        async function loadFromGitHub() {
            if (!githubToken || !githubUser) {
                showAlert('Please connect to GitHub first', 'error');
                showSetup();
                return;
            }

            try {
                setSyncStatus('github', 'syncing');
                addDebugLog('Starting GitHub full database load...');
                
                const repoName = 'timetracker-data';
                
                // Download full database
                const fullDataContent = await downloadFromGitHub(repoName, 'timetracker-full-data.json');
                
                if (!fullDataContent) {
                    showAlert('No GitHub data found. Upload data first using GitHub Sync.', 'info');
                    setSyncStatus('github', 'connected');
                    return;
                }
                
                const cloudData = JSON.parse(fullDataContent);
                
                // Check for conflicts and merge data (reuse OneDrive conflict logic)
                await handleDataConflicts(cloudData);
                
                setSyncStatus('github', 'connected');
                addDebugLog('GitHub full database load completed successfully');
                
            } catch (error) {
                setSyncStatus('github', 'disconnected');
                showAlert('GitHub load failed: ' + error.message, 'error');
                addDebugLog('GitHub load failed: ' + error.message);
            }
        }

        async function downloadFromGitHub(repoName, fileName) {
            try {
                addDebugLog(`Downloading ${fileName} from GitHub...`);
                
                const response = await fetch(`https://api.github.com/repos/${githubUser.login}/${repoName}/contents/${fileName}`, {
                    headers: {
                        'Authorization': `token ${githubToken}`,
                        'Accept': 'application/vnd.github.v3+json'
                    }
                });
                
                if (response.status === 404) {
                    addDebugLog(`File ${fileName} not found in GitHub repository`);
                    return null;
                }
                
                if (!response.ok) {
                    throw new Error(`Failed to download from GitHub: ${response.status} ${response.statusText}`);
                }
                
                const fileData = await response.json();
                const content = decodeURIComponent(escape(atob(fileData.content))); // Base64 decode
                
                addDebugLog(`Successfully downloaded ${fileName} from GitHub`);
                return content;
                
            } catch (error) {
                addDebugLog(`Error downloading ${fileName} from GitHub: ${error.message}`);
                throw error;
            }
        }

        function disconnectGitHub() {
            githubToken = null;
            githubUser = null;
            localStorage.removeItem('github_token');
            document.getElementById('githubTokenInput').value = '';
            hideGitHubConnectedControls();
            updateGitHubAuthStatus();
            updateGitHubStatus();
            showAlert('Disconnected from GitHub successfully', 'success');
            addDebugLog('Disconnected from GitHub');
        }

        // OneDrive sync functions - Enhanced with full data sync and conflict management
        async function syncToOneDrive() {
            if (!currentAccount) {
                showAlert('Please sign in to OneDrive first', 'error');
                showSetup();
                return;
            }

            try {
                setSyncStatus('onedrive', 'syncing');
                
                const accessToken = await getAccessToken();
                
                // Create TimeTracker folder if it doesn't exist
                await createTimeTrackerFolder(accessToken);
                
                // Upload full database
                const fullData = {
                    timeData: timeData,
                    habitsData: habitsData,
                    lastSync: new Date().toISOString(),
                    deviceInfo: {
                        userAgent: navigator.userAgent,
                        platform: navigator.platform,
                        timestamp: Date.now()
                    }
                };
                
                await uploadToOneDrive(accessToken, 'timetracker-full-data.json', JSON.stringify(fullData, null, 2));
                
                setSyncStatus('onedrive', 'connected');
                showAlert('Full database synced to OneDrive successfully!', 'success');
                
            } catch (error) {
                setSyncStatus('onedrive', 'disconnected');
                showAlert('OneDrive sync failed: ' + error.message, 'error');
            }
        }

        async function loadFromOneDrive() {
            if (!currentAccount) {
                showAlert('Please sign in to OneDrive first', 'error');
                showSetup();
                return;
            }

            try {
                setSyncStatus('onedrive', 'syncing');
                
                const accessToken = await getAccessToken();
                
                // Download full database
                const fullDataContent = await downloadFromOneDrive(accessToken, 'timetracker-full-data.json');
                
                if (!fullDataContent) {
                    showAlert('No cloud data found. Upload data first using OneDrive Sync.', 'info');
                    setSyncStatus('onedrive', 'connected');
                    return;
                }
                
                const cloudData = JSON.parse(fullDataContent);
                
                // Check for conflicts and merge data
                await handleDataConflicts(cloudData);
                
                setSyncStatus('onedrive', 'connected');
                
            } catch (error) {
                setSyncStatus('onedrive', 'disconnected');
                showAlert('OneDrive load failed: ' + error.message, 'error');
            }
        }

        async function handleDataConflicts(cloudData) {
            const localEntryCount = Object.keys(timeData).reduce((total, date) => {
                return total + Object.keys(timeData[date] || {}).length;
            }, 0);
            
            const cloudEntryCount = Object.keys(cloudData.timeData || {}).reduce((total, date) => {
                return total + Object.keys(cloudData.timeData[date] || {}).length;
            }, 0);
            
            console.log('=== CONFLICT DETECTION ===');
            console.log('Local entries:', localEntryCount);
            console.log('Cloud entries:', cloudEntryCount);
            
            // If no local data, just load cloud data
            if (localEntryCount === 0) {
                console.log('No local data, loading cloud data');
                loadCloudData(cloudData);
                showAlert('Cloud data loaded successfully!', 'success');
                return;
            }
            
            // If no cloud data, nothing to merge
            if (cloudEntryCount === 0) {
                showAlert('No cloud data to merge', 'info');
                return;
            }
            
            // Both have data - detect conflicts
            const conflicts = detectConflicts(timeData, cloudData.timeData || {});
            
            if (conflicts.length === 0) {
                // No conflicts, safe to merge
                console.log('No conflicts detected, merging data');
                mergeData(cloudData);
                showAlert(`Data merged successfully! Added ${cloudEntryCount} cloud entries.`, 'success');
            } else {
                // Conflicts found, show resolution dialog
                console.log('Conflicts detected:', conflicts);
                showConflictResolutionDialog(cloudData, conflicts);
            }
        }

        function detectConflicts(localData, cloudData) {
            const conflicts = [];
            
            Object.keys(cloudData).forEach(date => {
                if (localData[date]) {
                    const localDay = localData[date];
                    const cloudDay = cloudData[date];
                    
                    Object.keys(cloudDay).forEach(timeSlot => {
                        if (localDay[timeSlot] && localDay[timeSlot] !== cloudDay[timeSlot]) {
                            conflicts.push({
                                date: date,
                                timeSlot: timeSlot,
                                local: localDay[timeSlot],
                                cloud: cloudDay[timeSlot]
                            });
                        }
                    });
                }
            });
            
            return conflicts;
        }

        function showConflictResolutionDialog(cloudData, conflicts) {
            const conflictCount = conflicts.length;
            const cloudEntryCount = Object.keys(cloudData.timeData || {}).reduce((total, date) => {
                return total + Object.keys(cloudData.timeData[date] || {}).length;
            }, 0);
            
            const message = `Data conflict detected!\n\n` +
                `Found ${conflictCount} conflicting entries where both devices have different data for the same time slots.\n\n` +
                `Cloud data: ${cloudEntryCount} entries\n` +
                `Last synced: ${cloudData.lastSync ? new Date(cloudData.lastSync).toLocaleString() : 'Unknown'}\n\n` +
                `How would you like to resolve conflicts?`;
            
            // Create custom dialog
            const dialog = document.createElement('div');
            dialog.style.cssText = `
                position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: rgba(0,0,0,0.7); display: flex; align-items: center;
                justify-content: center; z-index: 2000;
            `;
            
            dialog.innerHTML = `
                <div style="background: white; padding: 24px; border-radius: 12px; max-width: 500px; width: 90%;">
                    <h3 style="margin: 0 0 16px 0; color: #dc2626;">‚ö†Ô∏è Data Conflict Detected</h3>
                    <p style="margin-bottom: 16px; line-height: 1.5;">
                        Found <strong>${conflictCount} conflicting entries</strong> where both devices have different data for the same time slots.
                    </p>
                    <div style="background: #f3f4f6; padding: 12px; border-radius: 6px; margin-bottom: 16px; font-family: monospace; font-size: 12px;">
                        <strong>Cloud data:</strong> ${cloudEntryCount} entries<br>
                        <strong>Last synced:</strong> ${cloudData.lastSync ? new Date(cloudData.lastSync).toLocaleString() : 'Unknown'}
                    </div>
                    <p style="margin-bottom: 20px; font-weight: 600;">How would you like to resolve conflicts?</p>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                        <button onclick="resolveConflicts('merge')" style="padding: 12px; background: #10b981; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                            üîÑ Smart Merge (Recommended)
                            <div style="font-size: 11px; opacity: 0.9; margin-top: 4px;">Keep both, merge non-conflicting data, prefer most recent for conflicts</div>
                        </button>
                        <button onclick="resolveConflicts('cloud')" style="padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                            ‚òÅÔ∏è Use Cloud Data
                            <div style="font-size: 11px; opacity: 0.9; margin-top: 4px;">Replace local data with cloud data (local changes will be lost)</div>
                        </button>
                        <button onclick="resolveConflicts('local')" style="padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 500;">
                            üíª Keep Local Data
                            <div style="font-size: 11px; opacity: 0.9; margin-top: 4px;">Keep current local data, add non-conflicting cloud data</div>
                        </button>
                        <button onclick="resolveConflicts('cancel')" style="padding: 8px; background: #6b7280; color: white; border: none; border-radius: 6px; cursor: pointer;">
                            Cancel
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
            
            // Store data for resolution
            window.pendingCloudData = cloudData;
            window.pendingConflicts = conflicts;
        }

        function resolveConflicts(strategy) {
            const dialog = document.querySelector('div[style*="z-index: 2000"]');
            if (dialog) dialog.remove();
            
            const cloudData = window.pendingCloudData;
            const conflicts = window.pendingConflicts;
            
            if (!cloudData) return;
            
            switch (strategy) {
                case 'merge':
                    smartMergeData(cloudData, conflicts);
                    showAlert(`Smart merge completed! Resolved ${conflicts.length} conflicts.`, 'success');
                    break;
                case 'cloud':
                    loadCloudData(cloudData);
                    showAlert('Local data replaced with cloud data', 'success');
                    break;
                case 'local':
                    mergeNonConflictingData(cloudData, conflicts);
                    showAlert('Merged non-conflicting cloud data, kept local conflicts', 'success');
                    break;
                case 'cancel':
                    showAlert('Sync cancelled', 'info');
                    return;
            }
            
            // Clean up
            delete window.pendingCloudData;
            delete window.pendingConflicts;
        }

        function smartMergeData(cloudData, conflicts) {
            // Start with cloud data as base
            const mergedTimeData = JSON.parse(JSON.stringify(cloudData.timeData || {}));
            const mergedHabitsData = JSON.parse(JSON.stringify(cloudData.habitsData || {}));
            
            // Add all local data
            Object.keys(timeData).forEach(date => {
                if (!mergedTimeData[date]) {
                    mergedTimeData[date] = {};
                }
                Object.keys(timeData[date]).forEach(timeSlot => {
                    mergedTimeData[date][timeSlot] = timeData[date][timeSlot];
                });
            });
            
            // For conflicts, prefer the most recent based on last sync time
            const cloudSyncTime = cloudData.lastSync ? new Date(cloudData.lastSync).getTime() : 0;
            const localSyncTime = Date.now() - (24 * 60 * 60 * 1000); // Assume local is older
            
            conflicts.forEach(conflict => {
                // For now, prefer cloud data in conflicts (can be made smarter)
                mergedTimeData[conflict.date][conflict.timeSlot] = conflict.cloud;
            });
            
            // Merge habits data
            Object.keys(habitsData).forEach(key => {
                mergedHabitsData[key] = habitsData[key];
            });
            
            // Apply merged data
            timeData = mergedTimeData;
            habitsData = mergedHabitsData;
            
            saveTimeData();
            saveHabitsData();
            refreshAllViews();
        }

        function loadCloudData(cloudData) {
            if (cloudData.timeData) {
                timeData = cloudData.timeData;
                saveTimeData();
            }
            
            if (cloudData.habitsData) {
                habitsData = cloudData.habitsData;
                saveHabitsData();
            }
            
            refreshAllViews();
        }

        function mergeData(cloudData) {
            // Merge without conflicts
            if (cloudData.timeData) {
                Object.keys(cloudData.timeData).forEach(date => {
                    if (!timeData[date]) {
                        timeData[date] = {};
                    }
                    Object.keys(cloudData.timeData[date]).forEach(timeSlot => {
                        if (!timeData[date][timeSlot]) {
                            timeData[date][timeSlot] = cloudData.timeData[date][timeSlot];
                        }
                    });
                });
                saveTimeData();
            }
            
            if (cloudData.habitsData) {
                Object.keys(cloudData.habitsData).forEach(key => {
                    if (!habitsData[key]) {
                        habitsData[key] = cloudData.habitsData[key];
                    }
                });
                saveHabitsData();
            }
            
            refreshAllViews();
        }

        function mergeNonConflictingData(cloudData, conflicts) {
            const conflictKeys = new Set();
            conflicts.forEach(conflict => {
                conflictKeys.add(`${conflict.date}-${conflict.timeSlot}`);
            });
            
            // Add only non-conflicting data
            if (cloudData.timeData) {
                Object.keys(cloudData.timeData).forEach(date => {
                    if (!timeData[date]) {
                        timeData[date] = {};
                    }
                    Object.keys(cloudData.timeData[date]).forEach(timeSlot => {
                        const key = `${date}-${timeSlot}`;
                        if (!conflictKeys.has(key) && !timeData[date][timeSlot]) {
                            timeData[date][timeSlot] = cloudData.timeData[date][timeSlot];
                        }
                    });
                });
                saveTimeData();
            }
            
            // Merge habits (less likely to conflict)
            if (cloudData.habitsData) {
                Object.keys(cloudData.habitsData).forEach(key => {
                    if (!habitsData[key]) {
                        habitsData[key] = cloudData.habitsData[key];
                    }
                });
                saveHabitsData();
            }
            
            refreshAllViews();
        }

        function refreshAllViews() {
            generateTimeGrid();
            updateSummary();
            updateWeeklyView();
            updateHabitsView();
            updateDataStatus();
        }

        async function createTimeTrackerFolder(accessToken) {
            try {
                const response = await fetch('https://graph.microsoft.com/v1.0/me/drive/root/children', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${accessToken}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        name: 'TimeTracker',
                        folder: {}
                    })
                });
                
                if (response.status === 409) {
                    // Folder already exists, that's fine
                    return;
                }
                
                if (!response.ok) {
                    throw new Error(`Failed to create folder: ${response.status}`);
                }
            } catch (error) {
                // Folder might already exist, continue
                console.log('Folder creation note:', error.message);
            }
        }

        async function uploadToOneDrive(accessToken, fileName, content) {
            const response = await fetch(`https://graph.microsoft.com/v1.0/me/drive/root:/TimeTracker/${fileName}:/content`, {
                method: 'PUT',
                headers: {
                    'Authorization': `Bearer ${accessToken}`,
                    'Content-Type': 'application/json'
                },
                body: content
            });

            if (!response.ok) {
                throw new Error(`Upload failed: ${response.status}`);
            }
        }

        async function downloadFromOneDrive(accessToken, fileName) {
            try {
                const response = await fetch(`https://graph.microsoft.com/v1.0/me/drive/root:/TimeTracker/${fileName}:/content`, {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (response.status === 404) {
                    return null; // File doesn't exist
                }

                if (!response.ok) {
                    throw new Error(`Download failed: ${response.status}`);
                }

                return await response.text();
            } catch (error) {
                console.log(`File ${fileName} not found or error:`, error.message);
                return null;
            }
        }

        // MSAL and OneDrive integration
        const msalConfig = {
            auth: {
                clientId: 'd006fc96-89ce-4dbe-8bd1-78daab15c1df',
                authority: 'https://login.microsoftonline.com/consumers',
                redirectUri: window.location.origin + window.location.pathname
            },
            cache: {
                cacheLocation: 'localStorage',
                storeAuthStateInCookie: false
            }
        };

        const loginRequest = {
            scopes: ['https://graph.microsoft.com/Files.ReadWrite', 'https://graph.microsoft.com/User.Read'],
            prompt: 'select_account'
        };

        function loadMSALLibrary() {
            const cdnSources = [
                'https://alcdn.msauth.net/browser/2.38.3/js/msal-browser.min.js',
                'https://cdn.jsdelivr.net/npm/@azure/msal-browser@2.38.3/lib/msal-browser.min.js',
                'https://unpkg.com/@azure/msal-browser@2.38.3/lib/msal-browser.min.js',
                'https://cdnjs.cloudflare.com/ajax/libs/msal/2.38.3/msal-browser.min.js'
            ];

            function tryLoadCDN(index) {
                if (index >= cdnSources.length) {
                    addDebugLog('All CDN sources failed to load MSAL library');
                    updateAuthStatus('MSAL library failed to load from all CDN sources');
                    return;
                }

                addDebugLog(`Trying to load MSAL from CDN ${index + 1}...`);
                
                const script = document.createElement('script');
                script.src = cdnSources[index];
                script.onload = function() {
                    addDebugLog(`MSAL loaded successfully from CDN ${index + 1}`);
                    initializeMSAL();
                };
                script.onerror = function() {
                    addDebugLog(`CDN ${index + 1} failed, trying next...`);
                    setTimeout(() => tryLoadCDN(index + 1), 1000);
                };
                document.head.appendChild(script);
            }

            tryLoadCDN(0);
        }

        function initializeMSAL() {
            try {
                if (typeof msal === 'undefined') {
                    throw new Error('MSAL library not loaded');
                }

                msalInstance = new msal.PublicClientApplication(msalConfig);
                
                msalInstance.initialize().then(() => {
                    addDebugLog('MSAL initialized successfully');
                    updateAuthStatus('Ready to sign in');
                    
                    const signInBtn = document.getElementById('signInBtn');
                    signInBtn.disabled = false;
                    signInBtn.innerHTML = '<span>üîê</span><span>Sign in with Microsoft</span>';
                    
                    // Check if already signed in
                    const accounts = msalInstance.getAllAccounts();
                    if (accounts.length > 0) {
                        currentAccount = accounts[0];
                        updateAuthStatus(`Signed in as: ${currentAccount.username}`);
                        showSignedInControls();
                        updateOneDriveStatus();
                    }
                }).catch(error => {
                    addDebugLog('MSAL initialization failed: ' + error.message);
                    updateAuthStatus('MSAL initialization failed');
                });
            } catch (error) {
                addDebugLog('Error creating MSAL instance: ' + error.message);
                updateAuthStatus('MSAL library not loaded');
            }
        }

        function updateAuthStatus(status) {
            document.getElementById('onedriveAuthStatus').textContent = 'Status: ' + status;
        }

        function showSignedInControls() {
            document.getElementById('signInBtn').style.display = 'none';
            document.getElementById('signedInControls').style.display = 'block';
        }

        function hideSignedInControls() {
            document.getElementById('signInBtn').style.display = 'flex';
            document.getElementById('signedInControls').style.display = 'none';
        }

        async function signInToOneDrive() {
            if (!msalInstance) {
                showAlert('MSAL not initialized', 'error');
                return;
            }

            try {
                addDebugLog('Starting sign-in process...');
                const response = await msalInstance.loginPopup(loginRequest);
                currentAccount = response.account;
                
                addDebugLog('Sign-in successful');
                updateAuthStatus(`Signed in as: ${currentAccount.username}`);
                showSignedInControls();
                updateOneDriveStatus();
                showAlert('OneDrive connection successful!', 'success');
                
                // Auto-close setup panel after 2 seconds
                setTimeout(() => {
                    hideSetup();
                }, 2000);
                
            } catch (error) {
                addDebugLog('Sign-in failed: ' + error.message);
                showAlert('Sign-in failed: ' + error.message, 'error');
            }
        }

        async function signOutFromOneDrive() {
            if (!msalInstance || !currentAccount) {
                return;
            }

            try {
                await msalInstance.logoutPopup({
                    account: currentAccount
                });
                
                currentAccount = null;
                updateAuthStatus('Signed out');
                hideSignedInControls();
                updateOneDriveStatus();
                showAlert('Signed out successfully', 'success');
                
            } catch (error) {
                addDebugLog('Sign-out failed: ' + error.message);
                showAlert('Sign-out failed: ' + error.message, 'error');
            }
        }

        async function testOneDriveConnection() {
            if (!currentAccount) {
                showAlert('Please sign in first', 'error');
                return;
            }

            try {
                const accessToken = await getAccessToken();
                const response = await fetch('https://graph.microsoft.com/v1.0/me/drive', {
                    headers: {
                        'Authorization': `Bearer ${accessToken}`
                    }
                });

                if (response.ok) {
                    const driveInfo = await response.json();
                    showAlert(`OneDrive connection successful! Drive: ${driveInfo.name}`, 'success');
                } else {
                    throw new Error(`HTTP ${response.status}`);
                }
            } catch (error) {
                showAlert('OneDrive connection failed: ' + error.message, 'error');
            }
        }

        async function getAccessToken() {
            if (!msalInstance || !currentAccount) {
                throw new Error('Not signed in');
            }

            try {
                const response = await msalInstance.acquireTokenSilent({
                    ...loginRequest,
                    account: currentAccount
                });
                return response.accessToken;
            } catch (error) {
                const response = await msalInstance.acquireTokenPopup(loginRequest);
                return response.accessToken;
            }
        }

        // Data Management Functions
        function showTab(tabName) {
            // Hide all views
            document.querySelectorAll('.view').forEach(view => {
                view.style.display = 'none';
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected view
            const viewElement = document.getElementById(tabName + 'View');
            if (viewElement) {
                viewElement.style.display = 'block';
            }
            
            // Add active class to selected tab
            event.target.classList.add('active');
            
            // Initialize content for each tab
            if (tabName === 'daily') {
                generateTimeGrid();
            } else if (tabName === 'weekly') {
                generateWeeklyGrid();
            } else if (tabName === 'habits') {
                generateHabitsGrid();
            } else if (tabName === 'data') {
                refreshDataView();
            }
        }

        function refreshDataView() {
            const allEntries = [];
            const duplicates = new Set();
            const conflicts = new Map();
            
            // Collect all entries
            Object.keys(timeData).forEach(date => {
                Object.keys(timeData[date]).forEach(timeKey => {
                    const symbol = timeData[date][timeKey];
                    const fullKey = `${date}-${timeKey}`;
                    
                    allEntries.push({
                        date: date,
                        timeKey: timeKey,
                        symbol: symbol,
                        fullKey: fullKey,
                        time: formatTimeKey(timeKey)
                    });
                });
            });
            
            // Find duplicates and conflicts
            const timeSlotMap = new Map();
            allEntries.forEach(entry => {
                const slotKey = `${entry.date}-${entry.timeKey}`;
                if (!timeSlotMap.has(slotKey)) {
                    timeSlotMap.set(slotKey, []);
                }
                timeSlotMap.get(slotKey).push(entry);
            });
            
            timeSlotMap.forEach((entries, slotKey) => {
                if (entries.length > 1) {
                    const symbols = [...new Set(entries.map(e => e.symbol))];
                    if (symbols.length === 1) {
                        // Exact duplicates
                        entries.slice(1).forEach(e => duplicates.add(e.fullKey));
                    } else {
                        // Conflicts (different symbols)
                        conflicts.set(slotKey, entries);
                    }
                }
            });
            
            // Update statistics
            document.getElementById('totalEntries').textContent = allEntries.length;
            document.getElementById('totalDates').textContent = Object.keys(timeData).length;
            document.getElementById('duplicatesCount').textContent = duplicates.size + conflicts.size;
            
            // Populate table
            populateDataTable(allEntries, duplicates, conflicts);
        }

        function populateDataTable(entries, duplicates, conflicts) {
            const tbody = document.getElementById('dataTableBody');
            tbody.innerHTML = '';
            
            entries.sort((a, b) => {
                if (a.date !== b.date) return a.date.localeCompare(b.date);
                return parseInt(a.timeKey.split('-')[0]) - parseInt(b.timeKey.split('-')[0]);
            });
            
            entries.forEach(entry => {
                const row = document.createElement('tr');
                
                // Determine row class
                let rowClass = '';
                if (duplicates.has(entry.fullKey)) {
                    rowClass = 'duplicate-row';
                }
                
                const slotKey = `${entry.date}-${entry.timeKey}`;
                if (conflicts.has(slotKey)) {
                    rowClass = 'conflict-row';
                }
                
                if (rowClass) {
                    row.className = rowClass;
                }
                
                row.innerHTML = `
                    <td>${entry.date}</td>
                    <td>${entry.time}</td>
                    <td class="symbol-cell">${entry.symbol}</td>
                    <td class="key-cell">${entry.fullKey}</td>
                    <td class="actions-cell">
                        <button class="btn-delete" onclick="deleteEntry('${entry.date}', '${entry.timeKey}')">
                            üóëÔ∏è
                        </button>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
        }

        function formatTimeKey(timeKey) {
            const [hour, quarter] = timeKey.split('-').map(Number);
            const minutes = quarter * 15;
            return `${hour.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
        }

        function deleteEntry(date, timeKey) {
            if (confirm(`Delete entry for ${date} at ${formatTimeKey(timeKey)}?`)) {
                if (timeData[date] && timeData[date][timeKey]) {
                    delete timeData[date][timeKey];
                    
                    // Clean up empty date objects
                    if (Object.keys(timeData[date]).length === 0) {
                        delete timeData[date];
                    }
                    
                    saveTimeData();
                    refreshDataView();
                    refreshAllViews();
                    showAlert('Entry deleted successfully', 'success');
                }
            }
        }

        function findDuplicates() {
            const duplicates = [];
            const conflicts = [];
            
            Object.keys(timeData).forEach(date => {
                const timeSlots = {};
                
                Object.keys(timeData[date]).forEach(timeKey => {
                    const symbol = timeData[date][timeKey];
                    const slotKey = `${date}-${timeKey}`;
                    
                    if (!timeSlots[slotKey]) {
                        timeSlots[slotKey] = [];
                    }
                    timeSlots[slotKey].push({ timeKey, symbol });
                });
                
                Object.keys(timeSlots).forEach(slotKey => {
                    const entries = timeSlots[slotKey];
                    if (entries.length > 1) {
                        const symbols = [...new Set(entries.map(e => e.symbol))];
                        if (symbols.length === 1) {
                            duplicates.push({ slotKey, entries });
                        } else {
                            conflicts.push({ slotKey, entries });
                        }
                    }
                });
            });
            
            if (duplicates.length === 0 && conflicts.length === 0) {
                showAlert('No duplicates or conflicts found!', 'success');
                return;
            }
            
            let message = '';
            if (duplicates.length > 0) {
                message += `Found ${duplicates.length} exact duplicates\n`;
            }
            if (conflicts.length > 0) {
                message += `Found ${conflicts.length} time slot conflicts\n`;
            }
            
            showAlert(message, 'warning');
            refreshDataView();
        }

        function cleanAllDuplicates() {
            if (!confirm('This will automatically remove exact duplicates and prompt you to resolve conflicts. Continue?')) {
                return;
            }
            
            let duplicatesRemoved = 0;
            const conflicts = [];
            
            Object.keys(timeData).forEach(date => {
                const timeSlots = {};
                const toDelete = [];
                
                // Group entries by time slot
                Object.keys(timeData[date]).forEach(timeKey => {
                    const symbol = timeData[date][timeKey];
                    const slotKey = timeKey;
                    
                    if (!timeSlots[slotKey]) {
                        timeSlots[slotKey] = [];
                    }
                    timeSlots[slotKey].push({ timeKey, symbol });
                });
                
                // Process each time slot
                Object.keys(timeSlots).forEach(slotKey => {
                    const entries = timeSlots[slotKey];
                    if (entries.length > 1) {
                        const symbols = [...new Set(entries.map(e => e.symbol))];
                        
                        if (symbols.length === 1) {
                            // Exact duplicates - keep first, mark others for deletion
                            for (let i = 1; i < entries.length; i++) {
                                toDelete.push(entries[i].timeKey);
                                duplicatesRemoved++;
                            }
                        } else {
                            // Conflicts - need user resolution
                            conflicts.push({
                                date: date,
                                timeKey: slotKey,
                                entries: entries
                            });
                        }
                    }
                });
                
                // Delete duplicates
                toDelete.forEach(timeKey => {
                    delete timeData[date][timeKey];
                });
                
                // Clean up empty date objects
                if (Object.keys(timeData[date]).length === 0) {
                    delete timeData[date];
                }
            });
            
            if (duplicatesRemoved > 0) {
                saveTimeData();
                showAlert(`Removed ${duplicatesRemoved} exact duplicates`, 'success');
            }
            
            if (conflicts.length > 0) {
                resolveConflicts(conflicts);
            } else {
                refreshDataView();
                refreshAllViews();
            }
        }

        function resolveConflicts(conflicts) {
            if (conflicts.length === 0) {
                refreshDataView();
                refreshAllViews();
                return;
            }
            
            const conflict = conflicts[0];
            const remainingConflicts = conflicts.slice(1);
            
            showConflictDialog(conflict, () => {
                resolveConflicts(remainingConflicts);
            });
        }

        function showConflictDialog(conflict, onComplete) {
            const dialog = document.createElement('div');
            dialog.className = 'conflict-dialog';
            
            const time = formatTimeKey(conflict.timeKey);
            
            dialog.innerHTML = `
                <div class="conflict-content">
                    <h3>‚ö†Ô∏è Time Slot Conflict</h3>
                    <p>Multiple entries found for <strong>${conflict.date}</strong> at <strong>${time}</strong>:</p>
                    
                    <div class="conflict-entries">
                        ${conflict.entries.map((entry, index) => `
                            <div class="conflict-entry">
                                <input type="radio" name="conflictChoice" value="${index}" ${index === 0 ? 'checked' : ''}>
                                <span class="conflict-symbol">${entry.symbol}</span>
                                <span>Keep this entry</span>
                            </div>
                        `).join('')}
                    </div>
                    
                    <div class="conflict-actions">
                        <button class="btn btn-secondary" onclick="cancelConflictResolution()">Cancel</button>
                        <button class="btn btn-primary" onclick="resolveConflict('${conflict.date}', '${conflict.timeKey}', ${JSON.stringify(conflict.entries).replace(/"/g, '&quot;')}, ${onComplete})">
                            Resolve
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(dialog);
            window.currentConflictDialog = dialog;
        }

        function resolveConflict(date, timeKey, entries, onComplete) {
            const selectedIndex = document.querySelector('input[name="conflictChoice"]:checked').value;
            const selectedEntry = entries[parseInt(selectedIndex)];
            
            // Remove all entries for this time slot
            entries.forEach(entry => {
                delete timeData[date][entry.timeKey];
            });
            
            // Add back only the selected entry
            if (!timeData[date]) {
                timeData[date] = {};
            }
            timeData[date][timeKey] = selectedEntry.symbol;
            
            saveTimeData();
            
            // Close dialog
            if (window.currentConflictDialog) {
                document.body.removeChild(window.currentConflictDialog);
                window.currentConflictDialog = null;
            }
            
            showAlert('Conflict resolved successfully', 'success');
            
            if (onComplete) {
                onComplete();
            }
        }

        function cancelConflictResolution() {
            if (window.currentConflictDialog) {
                document.body.removeChild(window.currentConflictDialog);
                window.currentConflictDialog = null;
            }
        }

        function filterDataTable() {
            const dateFilter = document.getElementById('dateFilter').value.toLowerCase();
            const symbolFilter = document.getElementById('symbolFilter').value;
            const rows = document.querySelectorAll('#dataTableBody tr');
            
            rows.forEach(row => {
                const date = row.cells[0].textContent.toLowerCase();
                const symbol = row.cells[2].textContent;
                
                const dateMatch = !dateFilter || date.includes(dateFilter);
                const symbolMatch = !symbolFilter || symbol === symbolFilter;
                
                row.style.display = dateMatch && symbolMatch ? '' : 'none';
            });
        }

        function clearFilters() {
            document.getElementById('dateFilter').value = '';
            document.getElementById('symbolFilter').value = '';
            filterDataTable();
        }

        // Main initialization function
        function initializeApp() {
            console.log('=== INITIALIZING TIMETRACKER PRO ===');
            
            // Load data
            loadTimeData();
            loadHabitsData();
            
            // Load authentication
            loadGitHubAuth();
            loadMSALLibrary();
            
            // Set current date
            const today = new Date();
            currentDate = formatDate(today);
            currentWeekStart = getWeekStart(today);
            currentHabitsWeek = getWeekStart(today);
            
            // Update date inputs
            document.getElementById('currentDate').value = currentDate;
            
            // Initialize views
            generateTimeGrid();
            updateSummary();
            updateWeeklyView();
            updateHabitsView();
            updateDataStatus();
            
            // Update status indicators
            updateGitHubStatus();
            updateOneDriveStatus();
            
            console.log('=== INITIALIZATION COMPLETE ===');
            console.log('Today:', currentDate);
            console.log('Week start:', formatDate(currentWeekStart));
            console.log('Total data entries:', Object.keys(timeData).length);
        }

        // Initialize app when page loads
        document.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>

